// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "auth";

export enum UserRole {
  USER_ROLE_UNSPECIFIED = 0,
  ADMIN = 1,
  USER = 2,
  GHOST = 3,
  UNRECOGNIZED = -1,
}

export interface UserRegister {
  login: string;
  email: string;
  password: string;
  passwordConfirm: string;
}

export interface UserByEmail {
  email: string;
}

export interface AnswerUserByEmail {
  login: string;
  id: number;
  isActivate: boolean;
  isVerified: boolean;
  avatarUrl: string;
  coverUrl: string;
  role: UserRole;
  createdAt: Timestamp | undefined;
  updatedAt: Timestamp | undefined;
  email: string;
  passwordHash: string;
}

export const AUTH_PACKAGE_NAME = "auth";

function createBaseUserRegister(): UserRegister {
  return { login: "", email: "", password: "", passwordConfirm: "" };
}

export const UserRegister: MessageFns<UserRegister> = {
  encode(message: UserRegister, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.login !== "") {
      writer.uint32(10).string(message.login);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.passwordConfirm !== "") {
      writer.uint32(34).string(message.passwordConfirm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRegister {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRegister();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.login = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.passwordConfirm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserByEmail(): UserByEmail {
  return { email: "" };
}

export const UserByEmail: MessageFns<UserByEmail> = {
  encode(message: UserByEmail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserByEmail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserByEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAnswerUserByEmail(): AnswerUserByEmail {
  return {
    login: "",
    id: 0,
    isActivate: false,
    isVerified: false,
    avatarUrl: "",
    coverUrl: "",
    role: 0,
    createdAt: undefined,
    updatedAt: undefined,
    email: "",
    passwordHash: "",
  };
}

export const AnswerUserByEmail: MessageFns<AnswerUserByEmail> = {
  encode(message: AnswerUserByEmail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.login !== "") {
      writer.uint32(10).string(message.login);
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.isActivate !== false) {
      writer.uint32(24).bool(message.isActivate);
    }
    if (message.isVerified !== false) {
      writer.uint32(32).bool(message.isVerified);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(42).string(message.avatarUrl);
    }
    if (message.coverUrl !== "") {
      writer.uint32(50).string(message.coverUrl);
    }
    if (message.role !== 0) {
      writer.uint32(56).int32(message.role);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(74).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(82).string(message.email);
    }
    if (message.passwordHash !== "") {
      writer.uint32(90).string(message.passwordHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnswerUserByEmail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswerUserByEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.login = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActivate = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.coverUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.passwordHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface AuthServiceProtoClient {
  getUserById(request: UserRegister): Observable<Empty>;

  getUserByEmail(request: UserByEmail): Observable<AnswerUserByEmail>;
}

export interface AuthServiceProtoController {
  getUserById(request: UserRegister): void;

  getUserByEmail(request: UserByEmail): Promise<AnswerUserByEmail> | Observable<AnswerUserByEmail> | AnswerUserByEmail;
}

export function AuthServiceProtoControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getUserById", "getUserByEmail"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthServiceProto", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthServiceProto", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_PROTO_SERVICE_NAME = "AuthServiceProto";

export type AuthServiceProtoService = typeof AuthServiceProtoService;
export const AuthServiceProtoService = {
  getUserById: {
    path: "/auth.AuthServiceProto/getUserById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserRegister): Buffer => Buffer.from(UserRegister.encode(value).finish()),
    requestDeserialize: (value: Buffer): UserRegister => UserRegister.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getUserByEmail: {
    path: "/auth.AuthServiceProto/getUserByEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserByEmail): Buffer => Buffer.from(UserByEmail.encode(value).finish()),
    requestDeserialize: (value: Buffer): UserByEmail => UserByEmail.decode(value),
    responseSerialize: (value: AnswerUserByEmail): Buffer => Buffer.from(AnswerUserByEmail.encode(value).finish()),
    responseDeserialize: (value: Buffer): AnswerUserByEmail => AnswerUserByEmail.decode(value),
  },
} as const;

export interface AuthServiceProtoServer extends UntypedServiceImplementation {
  getUserById: handleUnaryCall<UserRegister, Empty>;
  getUserByEmail: handleUnaryCall<UserByEmail, AnswerUserByEmail>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
